Overview In recent years, disputes between Ukraine and Russia over territorial issues have persisted, including the Crimean Peninsula issue, gas disputes, and the crisis in Eastern Ukraine. As the crisis events between the two countries intensified, security incidents occurring in cyberspace may be even more intense than in reality. During Christmas 2015, Ukrainian national power departments suffered a fierce attack by an APT group, plunging 1.4 million residents in western Ukraine into a large-scale blackout amidst severe cold, causing panic and significant losses in the city. In contrast, APT attacks suffered by Russia have been rarely disclosed to the outside world. On November 25, 2018, the "Kerch Strait" incident suddenly occurred between Ukraine and Russia. Several Ukrainian naval vessels were involved in a fierce conflict with the Russian Navy while sailing through the Kerch Strait, attracting global attention. Shortly after the "Kerch Strait" incident, on November 29, 2018, the 360 Advanced Threat Response Team was the first globally to discover an APT attack targeting Russia. It is noteworthy that the samples related to this attack originated from Ukraine, while the attack target pointed to a medical institution affiliated with the Russian Presidential Executive Office. The attackers meticulously prepared a Russian-language employee questionnaire document. This document utilized the latest Flash zero-day vulnerability CVE-2018-15982 and a proprietary trojan program with a self-destruct function to carry out the attack. Various technical details indicated that this APT group was willing to spare no expense to compromise the target while remaining extremely cautious. After discovering the attack, we promptly reported the details of the zero-day vulnerability to Adobe. Adobe responded swiftly and urgently released a new Flash version 32.0.0.101 on December 5, fixing this zero-day vulnerability. Fig 1: Malicious document content According to the website (http://www.p2f.ru) of the attacked medical institution, it was established in 1965 by the Russian Federation Presidential Executive Office and is a specialized medical institution serving staff of the highest administrative, legislative, and judicial authorities of the Russian Federation, as well as scientists and artists. Since this attack was the first global discovery by 360, combined with the functional characteristics of the targeted medical institution, we named this APT attack "Operation Poison Needle". Currently, we are unable to determine the attacker's motivation and identity. However, the special background of this medical institution and the sensitive population it serves demonstrate the clear targeting of this attack. Furthermore, the attack occurring during the sensitive period of the "Kerch Strait" crisis also imbues it with unknown political intentions. Fig 2: Introduction to the targeted medical institution Attack Process Analysis The attacker initiated the attack by delivering a RAR compressed package. Opening the decoy document inside the compressed package would compromise the victim. The complete attack process is as follows: Fig 3: Malicious document attack process When the victim opens the employee questionnaire document, a Flash zero-day file will be played. Fig 4: Playing the Flash zero-day vulnerability After triggering the vulnerability, the WinRAR decompression program will manipulate files within the compressed package to execute the final PE payload, backup.exe. Fig 5: Vulnerability execution process tree Zero-Day Vulnerability Analysis Through analysis, we found that the CVE-2018-15982 zero-day vulnerability is a Use-After-Free (UAF) vulnerability in the com.adobe.tvsdk.mediacore.metadata package of Flash. The setObject method of the Metadata class, when saving a String type object (which belongs to RCObject) into the keySet member of the Metadata class object, did not use DRCWB (Deferred Reference Counted, with Write Barrier). Attackers exploited this by forcing garbage collection (GC) to obtain a dangling pointer. Based on this, they achieved multiple type confusions through multiple UAFs. Subsequently, they leveraged the interaction between two custom classes to achieve arbitrary read/write primitives. Using this, they leaked the virtual table pointer of a ByteArray to bypass ASLR. Finally, they bypassed DEP/CFG using methods similar to those in the leaked HackingTeam code to execute shellcode. Vulnerability Cause Analysis During the vulnerability trigger process, the address of the instantiated Metadata object in Flash is shown below. After cyclically calling the setObject method of Metadata, the keySet member of the Metadata object is shown below. Partial values of the keySet member are shown below. After forcing garbage collection, the freed memory portion of the keySet member is shown below. After reusing the memory with new Class5, a type confusion is caused, as shown below. Subsequently, the attacker also determines whether the exploit was successful by checking if the length property of a String object becomes 24. (A successful exploit causes type confusion; accessing the String object's length property at this point actually retrieves the value of the first member variable of Class5, which is 24). Through further decompilation and in-depth analysis, we found that the native function corresponding to the setObject method of the Metadata class is shown below; the actual functionality resides in setObject_impl. In Object_impl, the passed key (a String object) is directly saved into the keySet member of Metadata. The Buffer structure is defined as follows (the structure of the keySet member has some differences). add_keySet saves the passed key (String object), as shown in the code below. At this point, the garbage collector believes the passed key is unreferenced and reclaims its memory. However, the keySet member of the Metadata object still retains a pointer to the reclaimed memory. Subsequent allocation of new Class5 reuses this reclaimed memory, causing the UAF vulnerability. Exploit Analysis In the actual attack, the exploit code first allocates 0x1000 String objects, then immediately releases half of them, creating large memory holes of String objects for later exploitation. Next, the exploit code defines a Metadata object and uses the setObject method to store key-value pairs into it. The keySet member of the Metadata object holds a pointer to a memory region containing all keys (stored as Strings). It then forcibly triggers GC. Since the keySet member does not use DRCWB, it retains a dangling pointer to this memory region. The keys are then read from keySet into the arr_key array for later use. After obtaining the dangling pointer, the exploit code immediately allocates 256 Class5 objects stored in vec5 (a vector object). Since the memory size of a Class5 object is the same as a String object (0x18 bytes on 32-bit), and related objects are allocated within the same heap, according to the MMgc memory allocation algorithm, Class5 objects will occupy the memory space previously freed by (consecutive pairs of) String objects. The Class5 object is defined as follows, showing it has two uint member variables initialized to 0x18 and 2200 (0x898) respectively. It then iterates through the arr_key array to find a String object whose length has become 0x18 (in memory, the length field of the String object overlaps with the m_1 member of Class5). Based on this, it determines whether the environment is 32-bit or 64-bit and branches accordingly. Following the figure above, after finding the String index occupied by the Class5 object, the exploit code zeros out related properties of arr_key. This reduces the reference count of elements in arr_key (including the occupying Class5 object) to zero. In MMgc, objects with zero reference count immediately enter the ZCT (Zero Count Table). The exploit code then forcibly triggers GC to reclaim the memory in the ZCT, proceeding to the subsequent exploitation flow. Below we primarily analyze the 32-bit environment exploitation flow. In the 32-bit branch, after freeing the occupying Class5 objects, the exploit code immediately allocates 256 Class3 objects and stores them in another vector object, vec3. This process reuses the memory space previously occupied by one (or several) of the freed Class5 objects. The Class3 object is defined as follows. It is very similar to Class5, both occupying 0x18 bytes in memory. It can be seen that Class3 has an m_ba member and an m_Class1 member. m_ba is initialized to a ByteArray object, and m_Class1 is initialized to a Class1 object. The Class1 object is defined as follows: After the Class3 objects occupy the memory, the exploit code immediately iterates through vec5 to find a former Class5 object whose memory is now occupied by a Class3 object. Upon finding it, it saves the index of this Class5 object to this.index_1, and saves the m_Class1 member of this object (which is now a Class3 object) to this.ori_cls1_addr for later recovery. After two rounds of UAF, the exploit code then uses the saved index_1 index to modify the m_Class1 member of the reused Class3 object via vec5[index_1]. It immediately iterates through vec3 to find the modified Class3 object and saves its index in vec3 to this.index_2. At this point, the exploit code has obtained two vectors (vec5 and vec3) that can manipulate the same object, along with the object's index in each vector (index_1 and index_2). It will now construct arbitrary read/write primitives based on this. Let's look at the implementation of the arbitrary read/write primitive in the 32-bit environment. As seen in the figure below, leveraging the two confused class objects allows the implementation of arbitrary read/write primitives. The relevant code and its functionality are clearly commented in the figures above and below, so it won't be elaborated further here. For an explanation of the 0x10 offset subtraction, please refer to our previous analysis article on the CVE-2018-5002 vulnerability. The arbitrary read/write primitive in the 64-bit environment is largely similar to the 32-bit one, except that the class objects confused with Class5 are replaced with Class2 and Class4. Additionally, a Class0 is constructed for reading addresses in 64-bit. Here are the definitions of these three classes: Here is the arbitrary read/write primitive in the 64-bit environment. Since the primitive in 64-bit can only read/write 32 bits at a time, reading/writing a 64-bit address requires two operations. The exploit code leveraged the arbitrary read/write primitive to construct a series of utility functions. Using these functions, it ultimately read the address of VirtualProtect in kernel32.dll to bypass DEP later. The final exploitation employed methods identical to those used by HackingTeam to bypass DEP/CFG. As this process has been described online, it won't be explained in detail here. The shellcode for 32-bit and 64-bit was placed within the Class6 and Class7 classes, respectively. The shellcode ultimately called cmd to launch the WINRAR process, with the command-line parameters as follows: Vulnerability Patch Analysis The Flash version 32.0.0.101, urgently released by Adobe on December 5, fixed this zero-day vulnerability. Through dynamic analysis, we found that the patch uses an Array object to store all keys instead of a Buffer-like structure, thereby eliminating the reference problem. 1. An instantiated Metadata object during the patched version is shown below, with the address 0x7409540. 2. It can be seen that at offset 0x1C of the Metadata object, instead of the previous Buffer structure layout, there is now an Array object. Storing keys via an Array object avoids the previous issue. 3. After cyclically calling setObject to set key-values, the values in keySet are shown below. 4. Forcing garbage collection reveals that the pointers saved in keySet still point to valid strings, indicating that forced GC did not reclaim the key-value objects. Final Payload Analysis The PE payload backup.exe disguised itself as an NVIDIA graphics card control panel program, complete with detailed file description and version number. The file was digitally signed with a revoked certificate. After execution, backup.exe drops a file named NVIDIAControlPanel.exe in the local user's ProgramData directory. This file shares the same file information and digital signature as backup.exe but has a different file size. Through further analysis, we found the PE payload is a backdoor program heavily encrypted with VMProtect (VMP). After decryption and restoration, we found the main program primarily creates a window message loop with 8 main functional threads. 